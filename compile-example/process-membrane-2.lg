(module process-membrane-2)

(require "lengine-code/prelude.lg")
(require "lengine-code/stdlib.lg")
(require "lengine-code/collections.lg")

(fn n-th (n xs)
    (if (= 0 n) (head xs)
        (n-th (- n 1) (tail xs))))

(fn split-at-loop (acc xs delim)
    (case ((nil? xs) [acc (nil> xs)])
          (('unresolved? xs) ($ acc (xs) delim))
          ((= (head xs) delim) [acc (tail xs)])
          default ($ (+< acc (head xs)) (tail xs) delim)))

(fn split-at (xs delim)
    (split-at-loop (nil> xs) xs delim))

(fn line-stream (char-stream)
    (case ((nil? char-stream) 'nil)
          default (let ((got (split-at char-stream #\Linefeed))
                        (value (n-th 0 got))
                        (remains (n-th 1 got)))
                       ('cons (fold value "" +) #(line-stream remains)))))

;;; Read file in Sequence type
(def fs (file-stream "./102521_membrane_GC_cell_lines.csv"))
(println (take 10 fs))

(def file-sequence (stream (line-stream fs)))
(println (take 10 file-sequence))

(fn head-values-unresolved (line-stream)
    (case ((nil? line-stream) 'nil)
          (('unresolved? line-stream) (stream #(head-values-unresolved (line-stream))))
          default (let ((line (head line-stream))
                        (value (head (split line #\,))))
                       ('cons value (head-values-unresolved (tail line-stream))))))

(def head-values (head-values-unresolved file-sequence))

(fn parse-double? (x)
  (try (do (double x) return true)
    (recover e false)))

(fn 'filter (p xs)
    (case (('unresolved? xs) (stream #('filter p (xs))))
          ((nil? xs) (nil> xs))
          ((p (head xs)) ('cons (head xs) ($ p (tail xs))))
          default ($ p (tail xs))))

(fn 'filter-not (p xs)
    ('filter ^((x) (not (p x))) xs))

(fn 'map (f xs)
    (case (('unresolved? xs) (stream #('map f (xs))))
          ((nil? xs) (nil> xs))
          default ('cons (f (head xs)) ('map f (tail xs)))))

(fn calc (acc n xs)
    (case ((nil? xs) { :sum acc
                       :avg (/ acc n) })
          (('unresolved? xs) ($ acc n (xs)))
          ((nan? (head xs)) ($ acc n (tail xs)))
          default ($ (+ acc (head xs)) (+ n 1) (tail xs))))

(println "step 1")
(def filtered-head-values ('filter parse-double? head-values))
(println filtered-head-values)

(println "step 2")
(def numbers ('map double filtered-head-values))
(println numbers)

(println "step 3")
(def stat (calc 0.0 0 numbers))

(def sum (:sum stat))
(def avg (:avg stat))

(println sum)
(println avg)
