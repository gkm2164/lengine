(module process-membrane-2)

(import std.split)
(import std.split-at)
(import std.map)
(import std.filter)
(import std.filter-not)
(import std.file-stream)

(fn n-th (n xs)
    (if (= 0 n) (head xs)
        (n-th (- n 1) (tail xs))))

(fn 'reverse (xs)
    (^((acc xs)
        (if (nil? xs) acc
            ($ ('cons (head xs) acc) (tail xs))))
      (nil> xs) xs))

(fn split-at-loop (acc xs delim)
    (case ((nil? xs) [('reverse acc) (nil> xs)])
            (('unresolved? xs) ($ acc (xs) delim))
            ((= (head xs) delim) [('reverse acc) (tail xs)])
            default ($ ('cons (head xs) acc) (tail xs) delim)))

(fn split-at (xs delim)
    (split-at-loop (nil> xs) xs delim))

(fn line-stream (char-stream)
    (case ((nil? char-stream) 'nil)
          default (let ((got (split-at char-stream #\Linefeed))
                (value (n-th 0 got))
                (remains (n-th 1 got)))
               ('cons (fold value "" +) #(line-stream remains)))))

;;; Read file in Sequence type
(def fs (file-stream "./102521_membrane_GC_cell_lines.csv"))
(println (take 10 fs))
(def file-sequence (stream (line-stream fs)))
(println (take 10 file-sequence))

(fn head-values-unresolved (line-stream)
    (case ((nil? line-stream) 'nil)
          (('unresolved? line-stream) (stream #(head-values-unresolved (line-stream))))
          default (let ((line (head line-stream))
                        (value (head (split line #\,))))
                       ('cons value (head-values-unresolved (tail line-stream))))))

(def head-values (head-values-unresolved file-sequence))

(fn parse-double? (x)
    (try (do (double x) return true)
     (recover e false)))

(println "step 1")
(fn 'filter (p xs)
    (case (('unresolved? xs) (stream #('filter p (xs))))
          ((nil? xs) (nil> xs))
          ((p (head xs)) ('cons (head xs) ('filter p (tail xs))))
          default ('filter p (tail xs))))

(fn 'filter-not (p xs)
    ('filter ^((x) (not (p x))) xs))

(fn 'map (f xs)
    (case (('unresolved? xs) (stream #('map f (xs))))
          ((nil? xs) (nil> xs))
          default ('cons (f (head xs)) ('map f (tail xs)))))

(def filtered-head-values ('filter parse-double? head-values))

(println filtered-head-values)

(println "step 2")
(def numbers ('map double filtered-head-values))
(println numbers)

(println "step 3")
(fn calc (acc n xs)
    (case ((nil? xs) [acc (/ acc n)])
          ((nan? (head xs)) ($ acc n (tail xs)))
          default ($ (+ acc (head xs)) (+ n 1) (tail xs))))

(def stat (calc 0.0 0 numbers))

(def sum (head stat))
(def avg (head (tail stat)))

(println sum)
(println avg)
